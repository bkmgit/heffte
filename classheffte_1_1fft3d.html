<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Highly Efficient FFT for Exascale: HeFFTe v2.3: heffte::fft3d&lt; backend_tag, index &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="heffte.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Highly Efficient FFT for Exascale: HeFFTe v2.3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classheffte_1_1fft3d.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classheffte_1_1fft3d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">heffte::fft3d&lt; backend_tag, index &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__fft3d.html">Fast Fourier Transform</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines the plan for a 3-dimensional discrete Fourier transform performed on a MPI distributed data.  
 <a href="classheffte_1_1fft3d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="heffte__fft3d_8h_source.html">heffte_fft3d.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac5d40d64cf59b863e7478209996d6107"><td class="memItemLeft" align="right" valign="top"><a id="ac5d40d64cf59b863e7478209996d6107"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#ac5d40d64cf59b863e7478209996d6107">backend_executor</a> = typename <a class="el" href="structheffte_1_1one__dim__backend.html">one_dim_backend</a>&lt; backend_tag &gt;::executor</td></tr>
<tr class="memdesc:ac5d40d64cf59b863e7478209996d6107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to the wrapper class for the one dimensional backend library. <br /></td></tr>
<tr class="separator:ac5d40d64cf59b863e7478209996d6107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62ee60533b362f133f21cdd1911bec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb62ee60533b362f133f21cdd1911bec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a> = typename <a class="el" href="structheffte_1_1backend_1_1buffer__traits.html">backend::buffer_traits</a>&lt; backend_tag &gt;::template container&lt; T &gt;</td></tr>
<tr class="memdesc:aeb62ee60533b362f133f21cdd1911bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to the container template associated with the backend.  <a href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">More...</a><br /></td></tr>
<tr class="separator:aeb62ee60533b362f133f21cdd1911bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9b0e347c94f2bdb5376a19e3d878b6"><td class="memTemplParams" colspan="2"><a id="adb9b0e347c94f2bdb5376a19e3d878b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb9b0e347c94f2bdb5376a19e3d878b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#adb9b0e347c94f2bdb5376a19e3d878b6">real_buffer_container</a> = <a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a>&lt; typename <a class="el" href="structheffte_1_1define__standard__type.html">define_standard_type</a>&lt; T &gt;::type::value_type &gt;</td></tr>
<tr class="memdesc:adb9b0e347c94f2bdb5376a19e3d878b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of real values corresponding to the complex type T. <br /></td></tr>
<tr class="separator:adb9b0e347c94f2bdb5376a19e3d878b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f229cbf43a1e7eee55d762579e3a7e"><td class="memTemplParams" colspan="2"><a id="a39f229cbf43a1e7eee55d762579e3a7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39f229cbf43a1e7eee55d762579e3a7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a39f229cbf43a1e7eee55d762579e3a7e">output_buffer_container</a> = <a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a>&lt; typename <a class="el" href="structheffte_1_1transform__output.html">transform_output</a>&lt; T, backend_tag &gt;::type &gt;</td></tr>
<tr class="memdesc:a39f229cbf43a1e7eee55d762579e3a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of the output type corresponding to T, see <a class="el" href="classheffte_1_1fft3d.html#HeffteFFT3DCompatibleTypes">the table of compatible input and output types</a>. <br /></td></tr>
<tr class="separator:a39f229cbf43a1e7eee55d762579e3a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9d2b3e80788752589804c64b9b4afc"><td class="memItemLeft" align="right" valign="top"><a id="a3b9d2b3e80788752589804c64b9b4afc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a3b9d2b3e80788752589804c64b9b4afc">location_tag</a> = typename <a class="el" href="structheffte_1_1backend_1_1buffer__traits.html">backend::buffer_traits</a>&lt; backend_tag &gt;::location</td></tr>
<tr class="memdesc:a3b9d2b3e80788752589804c64b9b4afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-tag that is either <a class="el" href="structheffte_1_1tag_1_1cpu.html" title="Indicates the use of cpu backend and that all input/output data and arrays will be bound to the cpu.">tag::cpu</a> or <a class="el" href="structheffte_1_1tag_1_1gpu.html" title="Indicates the use of gpu backend and that all input/output data and arrays will be bound to the gpu d...">tag::gpu</a> to indicate the location of the data. <br /></td></tr>
<tr class="separator:a3b9d2b3e80788752589804c64b9b4afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structheffte_1_1backend_1_1device__instance"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structheffte_1_1backend_1_1device__instance')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structheffte_1_1backend_1_1device__instance.html">heffte::backend::device_instance&lt; backend::buffer_traits&lt; backend_tag &gt;::location &gt;</a></td></tr>
<tr class="memitem:a2b63f0b1deb23636cee0bfc94ffb564c inherit pub_types_structheffte_1_1backend_1_1device__instance"><td class="memItemLeft" align="right" valign="top"><a id="a2b63f0b1deb23636cee0bfc94ffb564c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheffte_1_1backend_1_1device__instance.html#a2b63f0b1deb23636cee0bfc94ffb564c">stream_type</a> = void *</td></tr>
<tr class="memdesc:a2b63f0b1deb23636cee0bfc94ffb564c inherit pub_types_structheffte_1_1backend_1_1device__instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the internal stream, the cpu uses just a void pointer. <br /></td></tr>
<tr class="separator:a2b63f0b1deb23636cee0bfc94ffb564c inherit pub_types_structheffte_1_1backend_1_1device__instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d337dece28dd2d2aa0e93af04f9763b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a1d337dece28dd2d2aa0e93af04f9763b">fft3d</a> (<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const <a class="el" href="classheffte_1_1fft3d.html#a27524f300afc834cd2dddd25beaee4b8">inbox</a>, <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const <a class="el" href="classheffte_1_1fft3d.html#a42a94caa949610c56767f5e7987af8df">outbox</a>, MPI_Comm const comm, <a class="el" href="structheffte_1_1plan__options.html">plan_options</a> const options=<a class="el" href="group__fft3d.html#ga91349491856002b9e5f4cdf24912c01a">default_options</a>&lt; backend_tag &gt;())</td></tr>
<tr class="memdesc:a1d337dece28dd2d2aa0e93af04f9763b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor creating a plan for FFT transform across the given communicator and using the box geometry.  <a href="classheffte_1_1fft3d.html#a1d337dece28dd2d2aa0e93af04f9763b">More...</a><br /></td></tr>
<tr class="separator:a1d337dece28dd2d2aa0e93af04f9763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5794a91773074377e6e59ded8face53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#ab5794a91773074377e6e59ded8face53">fft3d</a> (typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; <a class="el" href="classheffte_1_1fft3d.html#a3b9d2b3e80788752589804c64b9b4afc">location_tag</a> &gt;::<a class="el" href="structheffte_1_1backend_1_1device__instance.html#a2b63f0b1deb23636cee0bfc94ffb564c">stream_type</a> gpu_stream, <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const <a class="el" href="classheffte_1_1fft3d.html#a27524f300afc834cd2dddd25beaee4b8">inbox</a>, <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const <a class="el" href="classheffte_1_1fft3d.html#a42a94caa949610c56767f5e7987af8df">outbox</a>, MPI_Comm const comm, <a class="el" href="structheffte_1_1plan__options.html">plan_options</a> const options=<a class="el" href="group__fft3d.html#ga91349491856002b9e5f4cdf24912c01a">default_options</a>&lt; backend_tag &gt;())</td></tr>
<tr class="memdesc:ab5794a91773074377e6e59ded8face53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other constructor but accepts a GPU stream or queue.  <a href="classheffte_1_1fft3d.html#ab5794a91773074377e6e59ded8face53">More...</a><br /></td></tr>
<tr class="separator:ab5794a91773074377e6e59ded8face53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce4f8d8c20c3a00201350ccb08efd82"><td class="memItemLeft" align="right" valign="top"><a id="afce4f8d8c20c3a00201350ccb08efd82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#afce4f8d8c20c3a00201350ccb08efd82">fft3d</a> (int il0, int il1, int il2, int ih0, int ih1, int ih2, int io0, int io1, int io2, int ol0, int ol1, int ol2, int oh0, int oh1, int oh2, int oo0, int oo1, int oo2, MPI_Comm const comm, bool use_reorder, int algorithm, bool use_pencils)</td></tr>
<tr class="memdesc:afce4f8d8c20c3a00201350ccb08efd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only, used by the Fortran interface. <br /></td></tr>
<tr class="separator:afce4f8d8c20c3a00201350ccb08efd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b040e785ab22ab8a7d1e97416c923a1"><td class="memItemLeft" align="right" valign="top"><a id="a4b040e785ab22ab8a7d1e97416c923a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a4b040e785ab22ab8a7d1e97416c923a1">fft3d</a> (int il0, int il1, int il2, int ih0, int ih1, int ih2, int io0, int io1, int io2, int ol0, int ol1, int ol2, int oh0, int oh1, int oh2, int oo0, int oo1, int oo2, MPI_Comm const comm)</td></tr>
<tr class="memdesc:a4b040e785ab22ab8a7d1e97416c923a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only, used by the Fortran interface. <br /></td></tr>
<tr class="separator:a4b040e785ab22ab8a7d1e97416c923a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8e59360229edef921a7fb243dc3c52"><td class="memItemLeft" align="right" valign="top"><a id="ade8e59360229edef921a7fb243dc3c52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#ade8e59360229edef921a7fb243dc3c52">fft3d</a> (int il0, int il1, int il2, int ih0, int ih1, int ih2, int ol0, int ol1, int ol2, int oh0, int oh1, int oh2, MPI_Comm const comm)</td></tr>
<tr class="memdesc:ade8e59360229edef921a7fb243dc3c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only, used by the Fortran interface. <br /></td></tr>
<tr class="separator:ade8e59360229edef921a7fb243dc3c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1642e77a8b3f46da866434cbccdf82d9"><td class="memItemLeft" align="right" valign="top"><a id="a1642e77a8b3f46da866434cbccdf82d9"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a1642e77a8b3f46da866434cbccdf82d9">size_inbox</a> () const</td></tr>
<tr class="memdesc:a1642e77a8b3f46da866434cbccdf82d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the inbox defined in the constructor. <br /></td></tr>
<tr class="separator:a1642e77a8b3f46da866434cbccdf82d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726c48d33d5b5435f1798553b7a24aa5"><td class="memItemLeft" align="right" valign="top"><a id="a726c48d33d5b5435f1798553b7a24aa5"></a>
long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a726c48d33d5b5435f1798553b7a24aa5">size_outbox</a> () const</td></tr>
<tr class="memdesc:a726c48d33d5b5435f1798553b7a24aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the outbox defined in the constructor. <br /></td></tr>
<tr class="separator:a726c48d33d5b5435f1798553b7a24aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27524f300afc834cd2dddd25beaee4b8"><td class="memItemLeft" align="right" valign="top"><a id="a27524f300afc834cd2dddd25beaee4b8"></a>
<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a27524f300afc834cd2dddd25beaee4b8">inbox</a> () const</td></tr>
<tr class="memdesc:a27524f300afc834cd2dddd25beaee4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inbox. <br /></td></tr>
<tr class="separator:a27524f300afc834cd2dddd25beaee4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a94caa949610c56767f5e7987af8df"><td class="memItemLeft" align="right" valign="top"><a id="a42a94caa949610c56767f5e7987af8df"></a>
<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a42a94caa949610c56767f5e7987af8df">outbox</a> () const</td></tr>
<tr class="memdesc:a42a94caa949610c56767f5e7987af8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outbox. <br /></td></tr>
<tr class="separator:a42a94caa949610c56767f5e7987af8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249a705ba2a7b3de377d8ffa26283d12"><td class="memTemplParams" colspan="2">template&lt;typename input_type , typename output_type &gt; </td></tr>
<tr class="memitem:a249a705ba2a7b3de377d8ffa26283d12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12">forward</a> (input_type const input[], output_type output[], <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>) const</td></tr>
<tr class="memdesc:a249a705ba2a7b3de377d8ffa26283d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a forward Fourier transform using two arrays.  <a href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12">More...</a><br /></td></tr>
<tr class="separator:a249a705ba2a7b3de377d8ffa26283d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d70947661542edbfea7105c62b930"><td class="memTemplParams" colspan="2">template&lt;typename input_type , typename output_type &gt; </td></tr>
<tr class="memitem:a9a8d70947661542edbfea7105c62b930"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a9a8d70947661542edbfea7105c62b930">forward</a> (input_type const input[], output_type output[], output_type workspace[], <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>) const</td></tr>
<tr class="memdesc:a9a8d70947661542edbfea7105c62b930"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload utilizing a user-allocated workspace buffer.  <a href="classheffte_1_1fft3d.html#a9a8d70947661542edbfea7105c62b930">More...</a><br /></td></tr>
<tr class="separator:a9a8d70947661542edbfea7105c62b930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165715d91c47e78fa5bf4e1dab9b17fd"><td class="memTemplParams" colspan="2">template&lt;typename input_type , typename output_type &gt; </td></tr>
<tr class="memitem:a165715d91c47e78fa5bf4e1dab9b17fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a165715d91c47e78fa5bf4e1dab9b17fd">forward</a> (int const batch_size, input_type const input[], output_type output[], output_type workspace[], <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>) const</td></tr>
<tr class="memdesc:a165715d91c47e78fa5bf4e1dab9b17fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload allowing for a batch of FFTs to be performed in a single command.  <a href="classheffte_1_1fft3d.html#a165715d91c47e78fa5bf4e1dab9b17fd">More...</a><br /></td></tr>
<tr class="separator:a165715d91c47e78fa5bf4e1dab9b17fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc19100751760ab9293560a1dc241fa8"><td class="memTemplParams" colspan="2"><a id="afc19100751760ab9293560a1dc241fa8"></a>
template&lt;typename input_type , typename output_type &gt; </td></tr>
<tr class="memitem:afc19100751760ab9293560a1dc241fa8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#afc19100751760ab9293560a1dc241fa8">forward</a> (int const batch_size, input_type const input[], output_type output[], <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>) const</td></tr>
<tr class="memdesc:afc19100751760ab9293560a1dc241fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload that allocates workspace internally. <br /></td></tr>
<tr class="separator:afc19100751760ab9293560a1dc241fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1353a69326cea0ab6f63498ef3131d8"><td class="memTemplParams" colspan="2">template&lt;typename input_type &gt; </td></tr>
<tr class="memitem:ae1353a69326cea0ab6f63498ef3131d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classheffte_1_1fft3d.html#a39f229cbf43a1e7eee55d762579e3a7e">output_buffer_container</a>&lt; input_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#ae1353a69326cea0ab6f63498ef3131d8">forward</a> (<a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a>&lt; input_type &gt; const &amp;input, <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>)</td></tr>
<tr class="memdesc:ae1353a69326cea0ab6f63498ef3131d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector variant of <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a> using input and output buffer_container classes.  <a href="classheffte_1_1fft3d.html#ae1353a69326cea0ab6f63498ef3131d8">More...</a><br /></td></tr>
<tr class="separator:ae1353a69326cea0ab6f63498ef3131d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e723ec55ffaf3bb9e4534b31582e7f9"><td class="memTemplParams" colspan="2">template&lt;typename input_type , typename output_type &gt; </td></tr>
<tr class="memitem:a1e723ec55ffaf3bb9e4534b31582e7f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a1e723ec55ffaf3bb9e4534b31582e7f9">backward</a> (input_type const input[], output_type output[], <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>) const</td></tr>
<tr class="memdesc:a1e723ec55ffaf3bb9e4534b31582e7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a backward Fourier transform using two arrays.  <a href="classheffte_1_1fft3d.html#a1e723ec55ffaf3bb9e4534b31582e7f9">More...</a><br /></td></tr>
<tr class="separator:a1e723ec55ffaf3bb9e4534b31582e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936868279c36a1984ffdea7f0efe07e7"><td class="memTemplParams" colspan="2"><a id="a936868279c36a1984ffdea7f0efe07e7"></a>
template&lt;typename input_type , typename output_type &gt; </td></tr>
<tr class="memitem:a936868279c36a1984ffdea7f0efe07e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a936868279c36a1984ffdea7f0efe07e7">backward</a> (input_type const input[], output_type output[], input_type workspace[], <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>) const</td></tr>
<tr class="memdesc:a936868279c36a1984ffdea7f0efe07e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with user-provided workspace buffer, see the corresponding overload of <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a>. <br /></td></tr>
<tr class="separator:a936868279c36a1984ffdea7f0efe07e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8502a9d2d88c3fc9d610af5749c873"><td class="memTemplParams" colspan="2"><a id="abb8502a9d2d88c3fc9d610af5749c873"></a>
template&lt;typename input_type , typename output_type &gt; </td></tr>
<tr class="memitem:abb8502a9d2d88c3fc9d610af5749c873"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#abb8502a9d2d88c3fc9d610af5749c873">backward</a> (int const batch_size, input_type const input[], output_type output[], input_type workspace[], <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>) const</td></tr>
<tr class="memdesc:abb8502a9d2d88c3fc9d610af5749c873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for batch transforms, see the corresponding overload of <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a>. <br /></td></tr>
<tr class="separator:abb8502a9d2d88c3fc9d610af5749c873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a71a9d0dbd7845c0948db99284a9afa"><td class="memTemplParams" colspan="2"><a id="a9a71a9d0dbd7845c0948db99284a9afa"></a>
template&lt;typename input_type , typename output_type &gt; </td></tr>
<tr class="memitem:a9a71a9d0dbd7845c0948db99284a9afa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a9a71a9d0dbd7845c0948db99284a9afa">backward</a> (int const batch_size, input_type const input[], output_type output[], <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>) const</td></tr>
<tr class="memdesc:a9a71a9d0dbd7845c0948db99284a9afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for batch transforms with internally allocated workspace. <br /></td></tr>
<tr class="separator:a9a71a9d0dbd7845c0948db99284a9afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877dd9c619b4c8b09e73205b5e5c01e1"><td class="memTemplParams" colspan="2"><a id="a877dd9c619b4c8b09e73205b5e5c01e1"></a>
template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:a877dd9c619b4c8b09e73205b5e5c01e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a>&lt; scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a877dd9c619b4c8b09e73205b5e5c01e1">backward</a> (<a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a>&lt; scalar_type &gt; const &amp;input, <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>)</td></tr>
<tr class="memdesc:a877dd9c619b4c8b09e73205b5e5c01e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform complex-to-complex backward FFT using vector API. <br /></td></tr>
<tr class="separator:a877dd9c619b4c8b09e73205b5e5c01e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbd206c99ed69d960e574a78295eaea"><td class="memTemplParams" colspan="2"><a id="a1cbd206c99ed69d960e574a78295eaea"></a>
template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:a1cbd206c99ed69d960e574a78295eaea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classheffte_1_1fft3d.html#adb9b0e347c94f2bdb5376a19e3d878b6">real_buffer_container</a>&lt; scalar_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a1cbd206c99ed69d960e574a78295eaea">backward_real</a> (<a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a>&lt; scalar_type &gt; const &amp;input, <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling=<a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a>)</td></tr>
<tr class="memdesc:a1cbd206c99ed69d960e574a78295eaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform complex-to-real backward FFT using vector API (truncates the complex part). <br /></td></tr>
<tr class="separator:a1cbd206c99ed69d960e574a78295eaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b53983101465e795f039b7c3ee995b3"><td class="memItemLeft" align="right" valign="top"><a id="a3b53983101465e795f039b7c3ee995b3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#a3b53983101465e795f039b7c3ee995b3">get_scale_factor</a> (<a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a> scaling) const</td></tr>
<tr class="memdesc:a3b53983101465e795f039b7c3ee995b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scale factor for the given scaling. <br /></td></tr>
<tr class="separator:a3b53983101465e795f039b7c3ee995b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa820b442a35660123c7f8e652a210a8c"><td class="memItemLeft" align="right" valign="top"><a id="aa820b442a35660123c7f8e652a210a8c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#aa820b442a35660123c7f8e652a210a8c">size_workspace</a> () const</td></tr>
<tr class="memdesc:aa820b442a35660123c7f8e652a210a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the workspace size that will be used, size is measured in complex numbers. <br /></td></tr>
<tr class="separator:aa820b442a35660123c7f8e652a210a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadef8ba323b3049cb81bf5d36186070"><td class="memItemLeft" align="right" valign="top"><a id="afadef8ba323b3049cb81bf5d36186070"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1fft3d.html#afadef8ba323b3049cb81bf5d36186070">size_comm_buffers</a> () const</td></tr>
<tr class="memdesc:afadef8ba323b3049cb81bf5d36186070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size used by the communication workspace buffers (internal use). <br /></td></tr>
<tr class="separator:afadef8ba323b3049cb81bf5d36186070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structheffte_1_1backend_1_1device__instance"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structheffte_1_1backend_1_1device__instance')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structheffte_1_1backend_1_1device__instance.html">heffte::backend::device_instance&lt; backend::buffer_traits&lt; backend_tag &gt;::location &gt;</a></td></tr>
<tr class="memitem:a641aa853208673ca6458c1f9cfecc01c inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memItemLeft" align="right" valign="top"><a id="a641aa853208673ca6458c1f9cfecc01c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheffte_1_1backend_1_1device__instance.html#a641aa853208673ca6458c1f9cfecc01c">device_instance</a> (void *=nullptr)</td></tr>
<tr class="memdesc:a641aa853208673ca6458c1f9cfecc01c inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:a641aa853208673ca6458c1f9cfecc01c inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad405fb170c2b8d20c8d673ed414c4327 inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memItemLeft" align="right" valign="top"><a id="ad405fb170c2b8d20c8d673ed414c4327"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheffte_1_1backend_1_1device__instance.html#ad405fb170c2b8d20c8d673ed414c4327">~device_instance</a> ()=default</td></tr>
<tr class="memdesc:ad405fb170c2b8d20c8d673ed414c4327 inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:ad405fb170c2b8d20c8d673ed414c4327 inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b2c89b7100872ab6c704d3e4fb375e inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memItemLeft" align="right" valign="top"><a id="a50b2c89b7100872ab6c704d3e4fb375e"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheffte_1_1backend_1_1device__instance.html#a50b2c89b7100872ab6c704d3e4fb375e">stream</a> ()</td></tr>
<tr class="memdesc:a50b2c89b7100872ab6c704d3e4fb375e inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nullptr. <br /></td></tr>
<tr class="separator:a50b2c89b7100872ab6c704d3e4fb375e inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c921523208ca3187ea2c755985d56c inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memItemLeft" align="right" valign="top"><a id="ad9c921523208ca3187ea2c755985d56c"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheffte_1_1backend_1_1device__instance.html#ad9c921523208ca3187ea2c755985d56c">stream</a> () const</td></tr>
<tr class="memdesc:ad9c921523208ca3187ea2c755985d56c inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nullptr (const case). <br /></td></tr>
<tr class="separator:ad9c921523208ca3187ea2c755985d56c inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffcdf4f88f7c5843296bb395a85a901 inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memItemLeft" align="right" valign="top"><a id="a1ffcdf4f88f7c5843296bb395a85a901"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheffte_1_1backend_1_1device__instance.html#a1ffcdf4f88f7c5843296bb395a85a901">synchronize_device</a> () const</td></tr>
<tr class="memdesc:a1ffcdf4f88f7c5843296bb395a85a901 inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syncs the execution with the queue, no-op in the CPU case. <br /></td></tr>
<tr class="separator:a1ffcdf4f88f7c5843296bb395a85a901 inherit pub_methods_structheffte_1_1backend_1_1device__instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename backend_tag, typename index = int&gt;<br />
class heffte::fft3d&lt; backend_tag, index &gt;</h3>

<p>Defines the plan for a 3-dimensional discrete Fourier transform performed on a MPI distributed data. </p>
<dl class="section user"><dt>Overview</dt><dd>HeFFTe provides the frontend MPI communication algorithms that sync data movement across the MPI ranks, but relies on a backend implementation of FFT algorithms in one dimension. Multiple backends are supported (currently only the fftw3 library), an available backend has to be specified via a template tag. Forward and backward (inverse) transforms can be performed with different precision using the same <a class="el" href="classheffte_1_1fft3d.html" title="Defines the plan for a 3-dimensional discrete Fourier transform performed on a MPI distributed data.">heffte::fft3d</a> object so long as the input and output use the same distributed geometry.</dd></dl>
<dl class="section user"><dt>Boxes and Data Distribution</dt><dd>HeFFTe assumes that the input and output data is organized in three dimensional boxes, each MPI rank containing one input and one output box (currently those should not be empty). Each box is defined by three low and three high indexes, the indexes contained within a box range from the low to the high inclusively, i.e., the box <a class="el" href="structheffte_1_1box3d.html" title="A generic container that describes a 3d box of indexes.">heffte::box3d</a>({0, 0, 0}, {0, 0, 2}) contains three indexes (0, 0, 0), (0, 0, 1) and (0, 0, 2). The following conventions are observed:<ul>
<li>global indexing starts at 0</li>
<li>the boxes do not overlap (input can overlap with output, but the individual in/out boxed do not)</li>
<li>input and output boxes may be the same but do not have to overlap</li>
<li>no assumption is being made regarding the organization of ranks and boxes</li>
</ul>
</dd></dl>
<p><a class="anchor" id="HeffteFFT3DCompatibleTypes"></a></p><dl class="section user"><dt>Real and Complex Transforms</dt><dd>HeFFTe supports forward discrete Fourier transforms that take real or complex entries into complex output. The backward (inverse) transform takes complex data entries back to real or complex data. The precision must always match, e.g., float to std::complex&lt;float&gt;, double and std::complex&lt;double&gt;. <table class="doxtable">
<tr>
<td>Forward transform input </td><td>Forward transform output </td><td></td><td>Backward transform input </td><td>Backward transform output   </td></tr>
<tr>
<td>float </td><td>std::complex&lt;float&gt; </td><td></td><td>std::complex&lt;float&gt; </td><td>float  </td></tr>
<tr>
<td>double </td><td>std::complex&lt;double&gt; </td><td></td><td>std::complex&lt;double&gt; </td><td>double  </td></tr>
<tr>
<td>std::complex&lt;float&gt; </td><td>std::complex&lt;float&gt; </td><td></td><td>std::complex&lt;float&gt; </td><td>std::complex&lt;float&gt;  </td></tr>
<tr>
<td>std::complex&lt;double&gt; </td><td>std::complex&lt;double&gt; </td><td></td><td>std::complex&lt;double&gt; </td><td>std::complex&lt;double&gt;  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Complex Numbers</dt><dd>By default, HeFFTe works with the C++ native std::complex types, those are supported on both the CPU and GPU devices. However, many libraries provide their own complex types definitions and even though those are usually ABI compatible with the C++ standard types, the compiler treats those as distinct entities. Thus, HeFFTe recognizes the types defined by the backend libraries and additional types can be accepted with a specialization of <a class="el" href="structheffte_1_1is__ccomplex.html" title="Struct to specialize to allow HeFFTe to recognize custom single precision complex types.">heffte::is_ccomplex</a> and <a class="el" href="structheffte_1_1is__zcomplex.html" title="Struct to specialize to allow HeFFTe to recognize custom double precision complex types.">heffte::is_zcomplex</a>. <table class="doxtable">
<tr>
<td>Backend </td><td>Type </td><td>C++ Equivalent  </td></tr>
<tr>
<td rowspan="2">FFTW3 </td><td>fftwf_complex </td><td>std::complex&lt;float&gt;  </td></tr>
<tr>
<td>fftw_complex </td><td>std::complex&lt;double&gt;  </td></tr>
<tr>
<td rowspan="2">MKL </td><td>float _Complex </td><td>std::complex&lt;float&gt;  </td></tr>
<tr>
<td>double _Complex </td><td>std::complex&lt;double&gt;  </td></tr>
<tr>
<td rowspan="2">cuFFT </td><td>cufftComplex </td><td>std::complex&lt;float&gt;  </td></tr>
<tr>
<td>cufftDoubleComplex </td><td>std::complex&lt;double&gt;  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Scaling</dt><dd>Applying a forward and inverse DFT operations will leave the result as the original data multiplied by the total number of entries in the world box. Thus, the forward and backward operations are not truly inversing, unless the correct scaling is applied. By default, HeFFTe does not apply scaling, but the methods accept an optional parameter with three different options, see also <a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb" title="Indicates the scaling factor to apply on the result of an FFT operation.">heffte::scale</a>. <table class="doxtable">
<tr>
<td>Forward </td><td>Inverse  </td></tr>
<tr>
<td>forward(a, b, scaling::none) </td><td>forward(a, b, scaling::full)  </td></tr>
<tr>
<td>forward(a, b, scaling::symmetric) </td><td>forward(a, b, scaling::symmetric)  </td></tr>
<tr>
<td>forward(a, b, scaling::full) </td><td>forward(a, b, scaling::none)  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Batch FFTs</dt><dd>If multiple signals with the same distribution across the MPI-ranks need to be transformed, then heFFTe can perform batch operations. Observe the following scenario where we take multiple FFT operations on different signals stored contiguously: <div class="fragment"><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt; workspace(fft.size_workspace());</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;batch_size; i++)</div>
<div class="line">     fft.forward(input + i * fft.size_inbox(), output + i * fft.size_outbox(), workspace.data());</div>
</div><!-- fragment --> This can be done with the following call: <div class="fragment"><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt; workspace(batch_size * fft.size_workspace());</div>
<div class="line">fft.forward(batch_size, input, output, workspace.data());</div>
</div><!-- fragment --> The advantage of the batch operations is that communication buffers can be lumped together which reduces the latency when working with small signals. However, note the increased size of the workspace. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aeb62ee60533b362f133f21cdd1911bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62ee60533b362f133f21cdd1911bec">&#9670;&nbsp;</a></span>buffer_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index  = int&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classheffte_1_1fft3d.html">heffte::fft3d</a>&lt; backend_tag, index &gt;::<a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a> =  typename <a class="el" href="structheffte_1_1backend_1_1buffer__traits.html">backend::buffer_traits</a>&lt;backend_tag&gt;::template container&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to the container template associated with the backend. </p>
<p>Following C++ RAII style of resource management, HeFFTe uses containers to manage the temporary buffers used during transformation and communication. The CPU backends use std::vector while the GPU backends use heffte::cuda::vector. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d337dece28dd2d2aa0e93af04f9763b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d337dece28dd2d2aa0e93af04f9763b">&#9670;&nbsp;</a></span>fft3d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classheffte_1_1fft3d.html">heffte::fft3d</a>&lt; backend_tag, index &gt;::<a class="el" href="classheffte_1_1fft3d.html">fft3d</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>inbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>outbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm const&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1plan__options.html">plan_options</a> const&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__fft3d.html#ga91349491856002b9e5f4cdf24912c01a">default_options</a>&lt;backend_tag&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor creating a plan for FFT transform across the given communicator and using the box geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inbox</td><td>is the box for the non-transformed data, i.e., the input for the <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a> transform and the output of the <a class="el" href="classheffte_1_1fft3d.html#a1e723ec55ffaf3bb9e4534b31582e7f9" title="Performs a backward Fourier transform using two arrays.">backward()</a> transform. </td></tr>
    <tr><td class="paramname">outbox</td><td>is the box for the transformed data, i.e., the output for the <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a> transform and the input of the <a class="el" href="classheffte_1_1fft3d.html#a1e723ec55ffaf3bb9e4534b31582e7f9" title="Performs a backward Fourier transform using two arrays.">backward()</a> transform. </td></tr>
    <tr><td class="paramname">comm</td><td>is the MPI communicator with all ranks that will participate in the FFT. </td></tr>
    <tr><td class="paramname">options</td><td>is a set of options that define the FFT plan, see <a class="el" href="structheffte_1_1plan__options.html" title="Defines a set of tweaks and options to use in the plan generation.">heffte::plan_options</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5794a91773074377e6e59ded8face53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5794a91773074377e6e59ded8face53">&#9670;&nbsp;</a></span>fft3d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classheffte_1_1fft3d.html">heffte::fft3d</a>&lt; backend_tag, index &gt;::<a class="el" href="classheffte_1_1fft3d.html">fft3d</a> </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; <a class="el" href="classheffte_1_1fft3d.html#a3b9d2b3e80788752589804c64b9b4afc">location_tag</a> &gt;::<a class="el" href="structheffte_1_1backend_1_1device__instance.html#a2b63f0b1deb23636cee0bfc94ffb564c">stream_type</a>&#160;</td>
          <td class="paramname"><em>gpu_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>inbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>outbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm const&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1plan__options.html">plan_options</a> const&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__fft3d.html#ga91349491856002b9e5f4cdf24912c01a">default_options</a>&lt;backend_tag&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical to the other constructor but accepts a GPU stream or queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_stream</td><td>is an initialized GPU stream or queue, the actual type depends on the backend as follows:</td></tr>
  </table>
  </dd>
</dl>
<table class="doxtable">
<tr>
<td>CPU backend </td><td>void*, the stream is never referenced  </td></tr>
<tr>
<td>CUDA backend </td><td>cudaStream_t  </td></tr>
<tr>
<td>ROCm backend </td><td>hipStream_t  </td></tr>
<tr>
<td>oneAPI backend </td><td>sycl::queue &amp;  </td></tr>
</table>
<p>In all cases, heFFTe takes a non-owning reference or alias to the stream; deleting the stream is a responsibility of the user but should not be done before the heFFTe object is destroyed. If no stream is provided, heFFTe will use the default CUDA or HIP stream or a default internal SYCL queue; note in the SYCL case the internal queue will create a new SYCL context which is probably not optimal. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a249a705ba2a7b3de377d8ffa26283d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249a705ba2a7b3de377d8ffa26283d12">&#9670;&nbsp;</a></span>forward() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index  = int&gt; </div>
<div class="memtemplate">
template&lt;typename input_type , typename output_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classheffte_1_1fft3d.html">heffte::fft3d</a>&lt; backend_tag, index &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">input_type const&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">output_type&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a>&#160;</td>
          <td class="paramname"><em>scaling</em> = <code><a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a forward Fourier transform using two arrays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_type</td><td>is a type compatible with the input of a forward FFT. </td></tr>
    <tr><td class="paramname">output_type</td><td>is a type compatible with the output of a forward FFT.</td></tr>
  </table>
  </dd>
</dl>
<p>The <b>input_type</b> and <b>output_type</b> must be compatible, see <a class="el" href="classheffte_1_1fft3d.html#HeffteFFT3DCompatibleTypes">the table of compatible types</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>is an array of size at least <a class="el" href="classheffte_1_1fft3d.html#a1642e77a8b3f46da866434cbccdf82d9" title="Returns the size of the inbox defined in the constructor.">size_inbox()</a> holding the input data corresponding to the inbox </td></tr>
    <tr><td class="paramname">output</td><td>is an array of size at least <a class="el" href="classheffte_1_1fft3d.html#a726c48d33d5b5435f1798553b7a24aa5" title="Returns the size of the outbox defined in the constructor.">size_outbox()</a> and will be overwritten with the result from the transform corresponding to the outbox </td></tr>
    <tr><td class="paramname">scaling</td><td>defines the type of scaling to apply (default no-scaling).</td></tr>
  </table>
  </dd>
</dl>
<p>Note that in the complex-to-complex case, the two arrays can be the same, in which case the size must be at least std::max(<a class="el" href="classheffte_1_1fft3d.html#a1642e77a8b3f46da866434cbccdf82d9" title="Returns the size of the inbox defined in the constructor.">size_inbox()</a>, <a class="el" href="classheffte_1_1fft3d.html#a726c48d33d5b5435f1798553b7a24aa5" title="Returns the size of the outbox defined in the constructor.">size_outbox()</a>). Whether the same or different, padded entities of the arrays will not be accessed. </p>

</div>
</div>
<a id="a9a8d70947661542edbfea7105c62b930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8d70947661542edbfea7105c62b930">&#9670;&nbsp;</a></span>forward() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index  = int&gt; </div>
<div class="memtemplate">
template&lt;typename input_type , typename output_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classheffte_1_1fft3d.html">heffte::fft3d</a>&lt; backend_tag, index &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">input_type const&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">output_type&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">output_type&#160;</td>
          <td class="paramname"><em>workspace</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a>&#160;</td>
          <td class="paramname"><em>scaling</em> = <code><a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload utilizing a user-allocated workspace buffer. </p>
<p>HeFFTe requires additional buffers to for various MPI operations, e.g., pack-send-receive-unpack. In the standard overload, the extra memory will be allocated during the call to <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a> and released right after. However, allocating and deallocation of large buffers can have a measurable negative effect on performance. Optionally, the use can allocate the workspace buffer externally and pass it into the HeFFTe calls.</p>
<p>The workspace buffer must have size equal to <a class="el" href="classheffte_1_1fft3d.html#aa820b442a35660123c7f8e652a210a8c" title="Returns the workspace size that will be used, size is measured in complex numbers.">size_workspace()</a> and measured in number of complex scalars, e.g., std::complex&lt;float&gt; or std::complex&lt;double&gt; for single and double precision respectively. </p>

</div>
</div>
<a id="a165715d91c47e78fa5bf4e1dab9b17fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165715d91c47e78fa5bf4e1dab9b17fd">&#9670;&nbsp;</a></span>forward() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index  = int&gt; </div>
<div class="memtemplate">
template&lt;typename input_type , typename output_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classheffte_1_1fft3d.html">heffte::fft3d</a>&lt; backend_tag, index &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_type const&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">output_type&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">output_type&#160;</td>
          <td class="paramname"><em>workspace</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a>&#160;</td>
          <td class="paramname"><em>scaling</em> = <code><a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overload allowing for a batch of FFTs to be performed in a single command. </p>
<p>The inputs are the same as the overload that utilizes a workspace with the added <b>batch_size</b>. The size of the workspace must be a batch_size * <a class="el" href="classheffte_1_1fft3d.html#aa820b442a35660123c7f8e652a210a8c" title="Returns the workspace size that will be used, size is measured in complex numbers.">size_workspace()</a> </p>

</div>
</div>
<a id="ae1353a69326cea0ab6f63498ef3131d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1353a69326cea0ab6f63498ef3131d8">&#9670;&nbsp;</a></span>forward() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index  = int&gt; </div>
<div class="memtemplate">
template&lt;typename input_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classheffte_1_1fft3d.html#a39f229cbf43a1e7eee55d762579e3a7e">output_buffer_container</a>&lt;input_type&gt; <a class="el" href="classheffte_1_1fft3d.html">heffte::fft3d</a>&lt; backend_tag, index &gt;::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classheffte_1_1fft3d.html#aeb62ee60533b362f133f21cdd1911bec">buffer_container</a>&lt; input_type &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a>&#160;</td>
          <td class="paramname"><em>scaling</em> = <code><a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector variant of <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a> using input and output buffer_container classes. </p>
<p>Returns either std::vector or <a class="el" href="namespaceheffte_1_1cuda.html" title="Cuda specific methods.">heffte::cuda</a>:vector using only the C++ standard types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_type</td><td>is a type compatible with the input of a backward FFT, see <a class="el" href="classheffte_1_1fft3d.html#HeffteFFT3DCompatibleTypes">the table of compatible types</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>is a std::vector or heffte::cuda::vector with size at least <a class="el" href="classheffte_1_1fft3d.html#a1642e77a8b3f46da866434cbccdf82d9" title="Returns the size of the inbox defined in the constructor.">size_inbox()</a> corresponding to the input of <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a>. </td></tr>
    <tr><td class="paramname">scaling</td><td>defines the type of scaling to apply (default no-scaling).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector or heffte::cuda::vector with entries corresponding to the output type and with size equal to <a class="el" href="classheffte_1_1fft3d.html#a726c48d33d5b5435f1798553b7a24aa5" title="Returns the size of the outbox defined in the constructor.">size_outbox()</a> corresponding to the output of <a class="el" href="classheffte_1_1fft3d.html#a249a705ba2a7b3de377d8ffa26283d12" title="Performs a forward Fourier transform using two arrays.">forward()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>is the size of the <b>input</b> is less than <a class="el" href="classheffte_1_1fft3d.html#a1642e77a8b3f46da866434cbccdf82d9" title="Returns the size of the inbox defined in the constructor.">size_inbox()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This method allow for a more C++-like calls of the form: </p><div class="fragment"><div class="line">std::vector&lt;double&gt; x = ....;</div>
<div class="line">...</div>
<div class="line">heffte::fft3d fft(<a class="code" href="classheffte_1_1fft3d.html#a27524f300afc834cd2dddd25beaee4b8">inbox</a>, <a class="code" href="classheffte_1_1fft3d.html#a42a94caa949610c56767f5e7987af8df">outbox</a>, comm);</div>
<div class="line"><span class="keyword">auto</span> y = fft.forward(x); <span class="comment">// y will be std::vector&lt;std::complex&lt;double&gt;&gt;</span></div>
<div class="ttc" id="aclassheffte_1_1fft3d_html_a27524f300afc834cd2dddd25beaee4b8"><div class="ttname"><a href="classheffte_1_1fft3d.html#a27524f300afc834cd2dddd25beaee4b8">heffte::fft3d::inbox</a></div><div class="ttdeci">box3d&lt; index &gt; inbox() const</div><div class="ttdoc">Returns the inbox.</div><div class="ttdef"><b>Definition:</b> heffte_fft3d.h:303</div></div>
<div class="ttc" id="aclassheffte_1_1fft3d_html_a42a94caa949610c56767f5e7987af8df"><div class="ttname"><a href="classheffte_1_1fft3d.html#a42a94caa949610c56767f5e7987af8df">heffte::fft3d::outbox</a></div><div class="ttdeci">box3d&lt; index &gt; outbox() const</div><div class="ttdoc">Returns the outbox.</div><div class="ttdef"><b>Definition:</b> heffte_fft3d.h:305</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1e723ec55ffaf3bb9e4534b31582e7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e723ec55ffaf3bb9e4534b31582e7f9">&#9670;&nbsp;</a></span>backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index  = int&gt; </div>
<div class="memtemplate">
template&lt;typename input_type , typename output_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classheffte_1_1fft3d.html">heffte::fft3d</a>&lt; backend_tag, index &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">input_type const&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">output_type&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fft3d.html#gae0a0922e2be72d5af2c9faad038874cb">scale</a>&#160;</td>
          <td class="paramname"><em>scaling</em> = <code><a class="el" href="group__fft3d.html#ggae0a0922e2be72d5af2c9faad038874cba334c4a4c42fdb79d7ebc3e73b517e6f8">scale::none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a backward Fourier transform using two arrays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">input_type</td><td>is a type compatible with the input of a backward FFT. </td></tr>
    <tr><td class="paramname">output_type</td><td>is a type compatible with the output of a backward FFT.</td></tr>
  </table>
  </dd>
</dl>
<p>The <b>input_type</b> and <b>output_type</b> must be compatible, see <a class="el" href="classheffte_1_1fft3d.html#HeffteFFT3DCompatibleTypes">the table of compatible types</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>is an array of size at least <a class="el" href="classheffte_1_1fft3d.html#a726c48d33d5b5435f1798553b7a24aa5" title="Returns the size of the outbox defined in the constructor.">size_outbox()</a> holding the input data corresponding to the outbox </td></tr>
    <tr><td class="paramname">output</td><td>is an array of size at least <a class="el" href="classheffte_1_1fft3d.html#a1642e77a8b3f46da866434cbccdf82d9" title="Returns the size of the inbox defined in the constructor.">size_inbox()</a> and will be overwritten with the result from the transform corresponding to the inbox </td></tr>
    <tr><td class="paramname">scaling</td><td>defines the type of scaling to apply (default no-scaling)</td></tr>
  </table>
  </dd>
</dl>
<p>Note that in the complex-to-complex case, the two arrays can be the same, in which case the size must be at least std::max(<a class="el" href="classheffte_1_1fft3d.html#a1642e77a8b3f46da866434cbccdf82d9" title="Returns the size of the inbox defined in the constructor.">size_inbox()</a>, <a class="el" href="classheffte_1_1fft3d.html#a726c48d33d5b5435f1798553b7a24aa5" title="Returns the size of the outbox defined in the constructor.">size_outbox()</a>). Whether the same or different, padded entities of the arrays will not be accessed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="heffte__fft3d_8h_source.html">heffte_fft3d.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceheffte.html">heffte</a></li><li class="navelem"><a class="el" href="classheffte_1_1fft3d.html">fft3d</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
