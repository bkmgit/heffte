<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Highly Efficient FFT for Exascale: HeFFTe v2.3: Box-geometry operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="heffte.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Highly Efficient FFT for Exascale: HeFFTe v2.3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__fft3dgeometry.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Box-geometry operations<div class="ingroups"><a class="el" href="group__fft3d.html">Fast Fourier Transform</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Box-geometry operations:</div>
<div class="dyncontent">
<div class="center"><img src="group__fft3dgeometry.png" border="0" usemap="#agroup____fft3dgeometry" alt=""/></div>
<map name="agroup____fft3dgeometry" id="agroup____fft3dgeometry">
<area shape="rect" href="group__fft3d.html" title=" " alt="" coords="5,5,160,31"/>
<area shape="rect" title=" " alt="" coords="208,5,375,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheffte_1_1rank__remap.html">heffte::rank_remap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps the local rank and the map from the global rank to the sub-ranks used in the work.  <a href="structheffte_1_1rank__remap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheffte_1_1ioboxes.html">heffte::ioboxes&lt; index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of lists of input-output boxes as used by the <a class="el" href="classheffte_1_1fft3d.html" title="Defines the plan for a 3-dimensional discrete Fourier transform performed on a MPI distributed data.">heffte::fft3d</a>.  <a href="structheffte_1_1ioboxes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9d66a94e08af65b980ed89db972f38bd"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga9d66a94e08af65b980ed89db972f38bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#ga9d66a94e08af65b980ed89db972f38bd">heffte::find_world</a> (std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;boxes)</td></tr>
<tr class="memdesc:ga9d66a94e08af65b980ed89db972f38bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the box that encapsulates all other boxes.  <a href="group__fft3dgeometry.html#ga9d66a94e08af65b980ed89db972f38bd">More...</a><br /></td></tr>
<tr class="separator:ga9d66a94e08af65b980ed89db972f38bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd726124c213a08070ad54587a08cee"><td class="memTemplParams" colspan="2"><a id="ga6bd726124c213a08070ad54587a08cee"></a>
template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga6bd726124c213a08070ad54587a08cee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#ga6bd726124c213a08070ad54587a08cee">heffte::match</a> (std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;shape0, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;shape1)</td></tr>
<tr class="memdesc:ga6bd726124c213a08070ad54587a08cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two vectors of boxes, returns true if all boxes match. <br /></td></tr>
<tr class="separator:ga6bd726124c213a08070ad54587a08cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d500c39e313762adba77fba0901dad7"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga8d500c39e313762adba77fba0901dad7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#ga8d500c39e313762adba77fba0901dad7">heffte::world_complete</a> (std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;boxes, <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const world)</td></tr>
<tr class="memdesc:ga8d500c39e313762adba77fba0901dad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the geometry of the world is as expected.  <a href="group__fft3dgeometry.html#ga8d500c39e313762adba77fba0901dad7">More...</a><br /></td></tr>
<tr class="separator:ga8d500c39e313762adba77fba0901dad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09d26871c884a0523c97d7f48d10efe"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:gab09d26871c884a0523c97d7f48d10efe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#gab09d26871c884a0523c97d7f48d10efe">heffte::split_world</a> (<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const world, std::array&lt; int, 3 &gt; const proc_grid, <a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a> const &amp;remap=<a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a>())</td></tr>
<tr class="memdesc:gab09d26871c884a0523c97d7f48d10efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the world box into a set of boxes that will be assigned to a process in the process grid.  <a href="group__fft3dgeometry.html#gab09d26871c884a0523c97d7f48d10efe">More...</a><br /></td></tr>
<tr class="separator:gab09d26871c884a0523c97d7f48d10efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff6700360dd5bea7caa67d8f1ad4012"><td class="memTemplParams" colspan="2"><a id="ga1ff6700360dd5bea7caa67d8f1ad4012"></a>
template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga1ff6700360dd5bea7caa67d8f1ad4012"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#ga1ff6700360dd5bea7caa67d8f1ad4012">heffte::is_pencils</a> (<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const world, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;shape, int <a class="el" href="group__fft3dmisc.html#ga2738b0dcfd330cf26181036ee5133a09">direction</a>)</td></tr>
<tr class="memdesc:ga1ff6700360dd5bea7caa67d8f1ad4012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the shape forms pencils in the given direction. <br /></td></tr>
<tr class="separator:ga1ff6700360dd5bea7caa67d8f1ad4012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61787c57c8ba9cf24d2bbe9a702e9a61"><td class="memTemplParams" colspan="2"><a id="ga61787c57c8ba9cf24d2bbe9a702e9a61"></a>
template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga61787c57c8ba9cf24d2bbe9a702e9a61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#ga61787c57c8ba9cf24d2bbe9a702e9a61">heffte::is_slab</a> (<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const world, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;shape, int direction1, int direction2)</td></tr>
<tr class="memdesc:ga61787c57c8ba9cf24d2bbe9a702e9a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the shape forms slabs in the given directions. <br /></td></tr>
<tr class="separator:ga61787c57c8ba9cf24d2bbe9a702e9a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeffaad7ebc798b6e829789ee8c22b24"><td class="memTemplParams" colspan="2"><a id="gaaeffaad7ebc798b6e829789ee8c22b24"></a>
template&lt;typename index &gt; </td></tr>
<tr class="memitem:gaaeffaad7ebc798b6e829789ee8c22b24"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#gaaeffaad7ebc798b6e829789ee8c22b24">heffte::reorder</a> (std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;shape, std::array&lt; int, 3 &gt; order)</td></tr>
<tr class="memdesc:gaaeffaad7ebc798b6e829789ee8c22b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the same shape, but sets a different order for each box. <br /></td></tr>
<tr class="separator:gaaeffaad7ebc798b6e829789ee8c22b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9004258695f15f6c9d0cffe8017a62"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga9a9004258695f15f6c9d0cffe8017a62"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#ga9a9004258695f15f6c9d0cffe8017a62">heffte::maximize_overlap</a> (std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;new_boxes, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;old_boxes, std::array&lt; int, 3 &gt; const order, <a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a> const &amp;remap)</td></tr>
<tr class="memdesc:ga9a9004258695f15f6c9d0cffe8017a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle the new boxes to maximize the overlap with the old boxes.  <a href="group__fft3dgeometry.html#ga9a9004258695f15f6c9d0cffe8017a62">More...</a><br /></td></tr>
<tr class="separator:ga9a9004258695f15f6c9d0cffe8017a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae060cb9f8d719ad2007d51ca4e6ef1b0"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:gae060cb9f8d719ad2007d51ca4e6ef1b0"><td class="memTemplItemLeft" align="right" valign="top">long long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#gae060cb9f8d719ad2007d51ca4e6ef1b0">heffte::count_connections</a> (std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;new_boxes, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;old_boxes)</td></tr>
<tr class="memdesc:gae060cb9f8d719ad2007d51ca4e6ef1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of point-to-point connections between the old and new box geometries.  <a href="group__fft3dgeometry.html#gae060cb9f8d719ad2007d51ca4e6ef1b0">More...</a><br /></td></tr>
<tr class="separator:gae060cb9f8d719ad2007d51ca4e6ef1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc239bfe5a333acdb4ca86b3b31a8fa6"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:gacc239bfe5a333acdb4ca86b3b31a8fa6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#gacc239bfe5a333acdb4ca86b3b31a8fa6">heffte::make_pencils</a> (<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const world, std::array&lt; int, 2 &gt; const proc_grid, int const dimension, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;source, std::array&lt; int, 3 &gt; const order, <a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a> const &amp;remap=<a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a>())</td></tr>
<tr class="memdesc:gacc239bfe5a333acdb4ca86b3b31a8fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the world into a grid of pencils and orders the pencils to the ranks that will minimize communication.  <a href="group__fft3dgeometry.html#gacc239bfe5a333acdb4ca86b3b31a8fa6">More...</a><br /></td></tr>
<tr class="separator:gacc239bfe5a333acdb4ca86b3b31a8fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0209c93b14c17886aa2673320fe3d974"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga0209c93b14c17886aa2673320fe3d974"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#ga0209c93b14c17886aa2673320fe3d974">heffte::make_slabs</a> (<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const world, int num_slabs, int const dimension1, int const dimension2, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;source, std::array&lt; int, 3 &gt; const order, <a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a> const &amp;remap)</td></tr>
<tr class="memdesc:ga0209c93b14c17886aa2673320fe3d974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the world into a set of slabs that span the given dimensions.  <a href="group__fft3dgeometry.html#ga0209c93b14c17886aa2673320fe3d974">More...</a><br /></td></tr>
<tr class="separator:ga0209c93b14c17886aa2673320fe3d974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a897b86af45ff818a86e8cab52ee62"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga80a897b86af45ff818a86e8cab52ee62"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; int, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fft3dgeometry.html#ga80a897b86af45ff818a86e8cab52ee62">heffte::proc_setup_min_surface</a> (<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const world, int num_procs)</td></tr>
<tr class="memdesc:ga80a897b86af45ff818a86e8cab52ee62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a grid of mpi-ranks that will minimize the area of each of the boxes.  <a href="group__fft3dgeometry.html#ga80a897b86af45ff818a86e8cab52ee62">More...</a><br /></td></tr>
<tr class="separator:ga80a897b86af45ff818a86e8cab52ee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>HeFFTe operates with indexes that are distributed in boxes across the mpi ranks. Several methods help manipulate such vectors of boxes, note that in each instance the order of the boxes in a single vector should always match. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9d66a94e08af65b980ed89db972f38bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d66a94e08af65b980ed89db972f38bd">&#9670;&nbsp;</a></span>find_world()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt;index&gt; heffte::find_world </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>boxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the box that encapsulates all other boxes. </p>
<p>Searches through the world.in boxes and computes the highest and lowest of all entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>the collection of all input and output boxes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d500c39e313762adba77fba0901dad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d500c39e313762adba77fba0901dad7">&#9670;&nbsp;</a></span>world_complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool heffte::world_complete </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>world</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the geometry of the world is as expected. </p>
<p>Runs simple checks to ensure that the inboxes will fill the world. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>is the collection of all world boxes </td></tr>
    <tr><td class="paramname">world</td><td>the box that incorporates all other boxes</td></tr>
  </table>
  </dd>
</dl>
<p>The check is not very rigorous at the moment, a true rigorous test will probably be too expensive unless lots of thought is put into it. </p>

</div>
</div>
<a id="gab09d26871c884a0523c97d7f48d10efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab09d26871c884a0523c97d7f48d10efe">&#9670;&nbsp;</a></span>split_world()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt;index&gt; &gt; heffte::split_world </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 3 &gt; const&#160;</td>
          <td class="paramname"><em>proc_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a> const &amp;&#160;</td>
          <td class="paramname"><em>remap</em> = <code><a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the world box into a set of boxes that will be assigned to a process in the process grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>is a box describing all indexes of consideration, there is no assumption on the lower or upper bound of the world </td></tr>
    <tr><td class="paramname">proc_grid</td><td>describes the number of boxes in each dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of non-overlapping boxes with union that fills the world where each box contains approximately the same number of indexes </dd></dl>

</div>
</div>
<a id="ga9a9004258695f15f6c9d0cffe8017a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a9004258695f15f6c9d0cffe8017a62">&#9670;&nbsp;</a></span>maximize_overlap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt;index&gt; &gt; heffte::maximize_overlap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>new_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>old_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 3 &gt; const&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a> const &amp;&#160;</td>
          <td class="paramname"><em>remap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuffle the new boxes to maximize the overlap with the old boxes. </p>
<p>A reshape operation from an old to a new configuration will require as much MPI communication as the lack of overlap between the two box sets, hence using a heuristic algorithms, in an attempt to find a reordering of the boxes to increase the overlap with the old and new. Also assigns the given order to the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_boxes</td><td>is a set of new boxes to be reordered </td></tr>
    <tr><td class="paramname">old_boxes</td><td>is the current box configuration </td></tr>
    <tr><td class="paramname">order</td><td>is the new order to be assigned to the result boxes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae060cb9f8d719ad2007d51ca4e6ef1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae060cb9f8d719ad2007d51ca4e6ef1b0">&#9670;&nbsp;</a></span>count_connections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long heffte::count_connections </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>new_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>old_boxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of point-to-point connections between the old and new box geometries. </p>
<p>Given a grid factorization of (a, b) the split into pencils can be done as either (1, a, b) or (1, b, a), the <a class="el" href="group__fft3dgeometry.html#gacc239bfe5a333acdb4ca86b3b31a8fa6" title="Breaks the world into a grid of pencils and orders the pencils to the ranks that will minimize commun...">heffte::make_pencils()</a> method computes both factorizations and selects the one that will lead to fewer point-to-point communications. This allows the pencil rotations to be done within the rows/columns of the 2D grid as opposed to communicating between all available ranks. </p>

</div>
</div>
<a id="gacc239bfe5a333acdb4ca86b3b31a8fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc239bfe5a333acdb4ca86b3b31a8fa6">&#9670;&nbsp;</a></span>make_pencils()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt;index&gt; &gt; heffte::make_pencils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 2 &gt; const&#160;</td>
          <td class="paramname"><em>proc_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 3 &gt; const&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a> const &amp;&#160;</td>
          <td class="paramname"><em>remap</em> = <code><a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Breaks the world into a grid of pencils and orders the pencils to the ranks that will minimize communication. </p>
<p>A pencil is a box with one dimension that matches the entire world, a pencils grid is a two-dimensional grid of boxes that captures a three dimensional world box.</p>
<p>This calls <a class="el" href="group__fft3dgeometry.html#gab09d26871c884a0523c97d7f48d10efe" title="Splits the world box into a set of boxes that will be assigned to a process in the process grid.">heffte::split_world()</a> and then rearranges the list so that performing a reshape operation from the source to the resulting list will minimize communication. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>is a box describing all indexes of consideration, it is assumed that the world is the union of the <b>source</b> boxes </td></tr>
    <tr><td class="paramname">proc_grid</td><td>gives the number of boxes to use for the two-by-two grid </td></tr>
    <tr><td class="paramname">dimension</td><td>is 0, 1, or 2, indicating the direction of orientation of the pencils, e.g., dimension 1 means that pencil.size[1] == world.size[1] for each pencil in the output list </td></tr>
    <tr><td class="paramname">source</td><td>is the current distribution of boxes across MPI ranks, and will be used as a reference when remapping boxes to ranks </td></tr>
    <tr><td class="paramname">order</td><td>is the box index order (fast, mid, slow) that will be assigned to the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sorted list of non-overlapping pencils which union is the <b>world</b> box </dd></dl>

</div>
</div>
<a id="ga0209c93b14c17886aa2673320fe3d974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0209c93b14c17886aa2673320fe3d974">&#9670;&nbsp;</a></span>make_slabs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt;index&gt; &gt; heffte::make_slabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_slabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>dimension1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>dimension2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; int, 3 &gt; const&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1rank__remap.html">rank_remap</a> const &amp;&#160;</td>
          <td class="paramname"><em>remap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Breaks the world into a set of slabs that span the given dimensions. </p>
<p>The method is near identical to make_pencils, but the slabs span two dimensions. </p>

</div>
</div>
<a id="ga80a897b86af45ff818a86e8cab52ee62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a897b86af45ff818a86e8cab52ee62">&#9670;&nbsp;</a></span>proc_setup_min_surface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;int, 3&gt; heffte::proc_setup_min_surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_procs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a grid of mpi-ranks that will minimize the area of each of the boxes. </p>
<p>Given the world box of indexes, generate the dimensions of a 3d grid of mpi-ranks, where the grid is chosen to minimize the total surface area of each of the boxes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>is the box of all indexes starting from 0. </td></tr>
    <tr><td class="paramname">num_procs</td><td>is the total number of mpi-ranks to use for the process grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dimensions of the 3d grid that will minimize the size of each box. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
