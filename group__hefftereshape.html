<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Highly Efficient FFT for Exascale: HeFFTe v2.3: Reshape operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="heffte.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Highly Efficient FFT for Exascale: HeFFTe v2.3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__hefftereshape.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Reshape operations<div class="ingroups"><a class="el" href="group__fft3d.html">Fast Fourier Transform</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Reshape operations:</div>
<div class="dyncontent">
<div class="center"><img src="group__hefftereshape.png" border="0" usemap="#agroup____hefftereshape" alt=""/></div>
<map name="agroup____hefftereshape" id="agroup____hefftereshape">
<area shape="rect" href="group__fft3d.html" title=" " alt="" coords="5,5,160,31"/>
<area shape="rect" title=" " alt="" coords="208,5,347,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1reshape3d__base.html">heffte::reshape3d_base&lt; index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base reshape interface.  <a href="classheffte_1_1reshape3d__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1reshape3d__alltoall.html">heffte::reshape3d_alltoall&lt; location_tag, packer, index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape algorithm based on the MPI_Alltoall() method.  <a href="classheffte_1_1reshape3d__alltoall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1reshape3d__alltoallv.html">heffte::reshape3d_alltoallv&lt; location_tag, packer, index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape algorithm based on the MPI_Alltoallv() method.  <a href="classheffte_1_1reshape3d__alltoallv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1reshape3d__pointtopoint.html">heffte::reshape3d_pointtopoint&lt; location_tag, packer, index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape algorithm based on the MPI_Send() and MPI_Irecv() methods.  <a href="classheffte_1_1reshape3d__pointtopoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classheffte_1_1reshape3d__transpose.html">heffte::reshape3d_transpose&lt; location_tag, index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case of the reshape that does not involve MPI communication but applies a transpose instead.  <a href="classheffte_1_1reshape3d__transpose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18fd5e8d860791584fe9b23b779e3b7b"><td class="memTemplParams" colspan="2">template&lt;typename index &gt; </td></tr>
<tr class="memitem:ga18fd5e8d860791584fe9b23b779e3b7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hefftereshape.html#ga18fd5e8d860791584fe9b23b779e3b7b">heffte::compute_overlap_map_transpose_pack</a> (int me, int nprocs, <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const destination, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;boxes, std::vector&lt; int &gt; &amp;proc, std::vector&lt; int &gt; &amp;offset, std::vector&lt; int &gt; &amp;sizes, std::vector&lt; <a class="el" href="structheffte_1_1pack__plan__3d.html">pack_plan_3d</a>&lt; index &gt;&gt; &amp;plans)</td></tr>
<tr class="memdesc:ga18fd5e8d860791584fe9b23b779e3b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an unpack plan where the boxes and the destination do not have the same order.  <a href="group__hefftereshape.html#ga18fd5e8d860791584fe9b23b779e3b7b">More...</a><br /></td></tr>
<tr class="separator:ga18fd5e8d860791584fe9b23b779e3b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd1dabaa0d659f85b6c882c2a14cd895"><td class="memTemplParams" colspan="2"><a id="gadd1dabaa0d659f85b6c882c2a14cd895"></a>
template&lt;typename index &gt; </td></tr>
<tr class="memitem:gadd1dabaa0d659f85b6c882c2a14cd895"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hefftereshape.html#gadd1dabaa0d659f85b6c882c2a14cd895">heffte::get_workspace_size</a> (std::array&lt; std::unique_ptr&lt; <a class="el" href="classheffte_1_1reshape3d__base.html">reshape3d_base</a>&lt; index &gt;&gt;, 4 &gt; const &amp;shapers)</td></tr>
<tr class="memdesc:gadd1dabaa0d659f85b6c882c2a14cd895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum workspace size used by the shapers. <br /></td></tr>
<tr class="separator:gadd1dabaa0d659f85b6c882c2a14cd895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63305c753a047ef4c408c5758095c820"><td class="memTemplParams" colspan="2">template&lt;typename location_tag , template&lt; typename device &gt; class packer = direct_packer, typename index &gt; </td></tr>
<tr class="memitem:ga63305c753a047ef4c408c5758095c820"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classheffte_1_1reshape3d__alltoall.html">reshape3d_alltoall</a>&lt; location_tag, packer, index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hefftereshape.html#ga63305c753a047ef4c408c5758095c820">heffte::make_reshape3d_alltoall</a> (typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; location_tag &gt;::stream_type q, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;input_boxes, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;output_boxes, bool uses_gpu_aware, MPI_Comm const comm)</td></tr>
<tr class="memdesc:ga63305c753a047ef4c408c5758095c820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that all the necessary work to establish the communication patterns.  <a href="group__hefftereshape.html#ga63305c753a047ef4c408c5758095c820">More...</a><br /></td></tr>
<tr class="separator:ga63305c753a047ef4c408c5758095c820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c749315467ce1f35fc29ad7584ab25"><td class="memTemplParams" colspan="2">template&lt;typename location_tag , template&lt; typename device &gt; class packer = direct_packer, typename index &gt; </td></tr>
<tr class="memitem:ga77c749315467ce1f35fc29ad7584ab25"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classheffte_1_1reshape3d__alltoallv.html">reshape3d_alltoallv</a>&lt; location_tag, packer, index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hefftereshape.html#ga77c749315467ce1f35fc29ad7584ab25">heffte::make_reshape3d_alltoallv</a> (typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; location_tag &gt;::stream_type q, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;input_boxes, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;output_boxes, bool use_gpu_aware, MPI_Comm const comm)</td></tr>
<tr class="memdesc:ga77c749315467ce1f35fc29ad7584ab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that all the necessary work to establish the communication patterns.  <a href="group__hefftereshape.html#ga77c749315467ce1f35fc29ad7584ab25">More...</a><br /></td></tr>
<tr class="separator:ga77c749315467ce1f35fc29ad7584ab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc59d58eea213e0d66f9bb47f3f0525"><td class="memTemplParams" colspan="2">template&lt;typename location_tag , template&lt; typename device &gt; class packer = direct_packer, typename index &gt; </td></tr>
<tr class="memitem:gaccc59d58eea213e0d66f9bb47f3f0525"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classheffte_1_1reshape3d__pointtopoint.html">reshape3d_pointtopoint</a>&lt; location_tag, packer, index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hefftereshape.html#gaccc59d58eea213e0d66f9bb47f3f0525">heffte::make_reshape3d_pointtopoint</a> (typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; location_tag &gt;::stream_type q, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;input_boxes, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;output_boxes, <a class="el" href="group__fft3d.html#ga4c9d07a6600d0e32939ec064c0604767">reshape_algorithm</a> algorithm, bool use_gpu_aware, MPI_Comm const comm)</td></tr>
<tr class="memdesc:gaccc59d58eea213e0d66f9bb47f3f0525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that all the necessary work to establish the communication patterns.  <a href="group__hefftereshape.html#gaccc59d58eea213e0d66f9bb47f3f0525">More...</a><br /></td></tr>
<tr class="separator:gaccc59d58eea213e0d66f9bb47f3f0525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f90b121c86d7ed6f0f9c6023523744"><td class="memTemplParams" colspan="2">template&lt;typename backend_tag , typename index &gt; </td></tr>
<tr class="memitem:ga19f90b121c86d7ed6f0f9c6023523744"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classheffte_1_1reshape3d__base.html">reshape3d_base</a>&lt; index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hefftereshape.html#ga19f90b121c86d7ed6f0f9c6023523744">heffte::make_reshape3d</a> (typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; typename <a class="el" href="structheffte_1_1backend_1_1buffer__traits.html">backend::buffer_traits</a>&lt; backend_tag &gt;::location &gt;::stream_type stream, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;input_boxes, std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;output_boxes, MPI_Comm const comm, <a class="el" href="structheffte_1_1plan__options.html">plan_options</a> const options)</td></tr>
<tr class="memdesc:ga19f90b121c86d7ed6f0f9c6023523744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a reshape3d instance.  <a href="group__hefftereshape.html#ga19f90b121c86d7ed6f0f9c6023523744">More...</a><br /></td></tr>
<tr class="separator:ga19f90b121c86d7ed6f0f9c6023523744"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A reshape operation is one that modifies the distribution of the indexes across an MPI communicator. In a special case, the reshape can correspond to a simple in-node data transpose (i.e., no communication).</p>
<p>The reshape operations inherit from a common <a class="el" href="classheffte_1_1reshape3d__base.html" title="Base reshape interface.">heffte::reshape3d_base</a> class that defines the apply method for different data-types and the sizes of the input, output, and scratch workspace. Reshape objects are usually wrapped in std::unique_ptr containers, which handles the polymorphic calls at runtime and also indicates the special case of no-reshape when the container is empty. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga18fd5e8d860791584fe9b23b779e3b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18fd5e8d860791584fe9b23b779e3b7b">&#9670;&nbsp;</a></span>compute_overlap_map_transpose_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void heffte::compute_overlap_map_transpose_pack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nprocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt; const&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1pack__plan__3d.html">pack_plan_3d</a>&lt; index &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>plans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an unpack plan where the boxes and the destination do not have the same order. </p>
<p>This method does not make any MPI calls, but it uses the set of boxes the define the current distribution of the indexes and computes the overlap and the proc, offset, and sizes vectors for the receive stage of an all-to-all-v communication patterns. In addition, a set of unpack plans is created where the order of the boxes and the destination are different, which will transpose the data. The plan has to be used in conjunction with the transpose packer. </p>

</div>
</div>
<a id="ga63305c753a047ef4c408c5758095c820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63305c753a047ef4c408c5758095c820">&#9670;&nbsp;</a></span>make_reshape3d_alltoall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename location_tag , template&lt; typename device &gt; class packer = direct_packer, typename index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classheffte_1_1reshape3d__alltoall.html">reshape3d_alltoall</a>&lt;location_tag, packer, index&gt; &gt; heffte::make_reshape3d_alltoall </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; location_tag &gt;::stream_type&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>output_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uses_gpu_aware</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm const&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method that all the necessary work to establish the communication patterns. </p>
<p>The purpose of the factory method is to isolate the initialization code and ensure that the internal state of the class is minimal and const-correct, i.e., objects do not hold onto data that will not be used in a reshape apply and the data is labeled const to prevent accidental corruption.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">location_tag</td><td>the location for the input/output buffers for the reshape operation, <a class="el" href="structheffte_1_1tag_1_1cpu.html" title="Indicates the use of cpu backend and that all input/output data and arrays will be bound to the cpu.">tag::cpu</a> or <a class="el" href="structheffte_1_1tag_1_1gpu.html" title="Indicates the use of gpu backend and that all input/output data and arrays will be bound to the gpu d...">tag::gpu</a> </td></tr>
    <tr><td class="paramname">packer</td><td>is the packer to use to parts of boxes into global send/recv buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>device stream </td></tr>
    <tr><td class="paramname">input_boxes</td><td>list of all input boxes across all ranks in the comm </td></tr>
    <tr><td class="paramname">output_boxes</td><td>list of all output boxes across all ranks in the comm </td></tr>
    <tr><td class="paramname">uses_gpu_aware</td><td>use MPI calls directly from the GPU (GPU backends only) </td></tr>
    <tr><td class="paramname">comm</td><td>the communicator associated with all the boxes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr containing an instance of the <a class="el" href="classheffte_1_1reshape3d__alltoall.html" title="Reshape algorithm based on the MPI_Alltoall() method.">heffte::reshape3d_alltoall</a></dd></dl>
<p>Note: the input and output boxes associated with this rank are located at position <a class="el" href="group__hefftempi.html#ga5df7514ec8acb2b7bcc642892ed22f67" title="Returns the rank of this process within the specified comm.">mpi::comm_rank()</a> in the respective lists. </p>

</div>
</div>
<a id="ga77c749315467ce1f35fc29ad7584ab25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c749315467ce1f35fc29ad7584ab25">&#9670;&nbsp;</a></span>make_reshape3d_alltoallv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename location_tag , template&lt; typename device &gt; class packer = direct_packer, typename index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classheffte_1_1reshape3d__alltoallv.html">reshape3d_alltoallv</a>&lt;location_tag, packer, index&gt; &gt; heffte::make_reshape3d_alltoallv </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; location_tag &gt;::stream_type&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>output_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_gpu_aware</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm const&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method that all the necessary work to establish the communication patterns. </p>
<p>The purpose of the factory method is to isolate the initialization code and ensure that the internal state of the class is minimal and const-correct, i.e., objects do not hold onto data that will not be used in a reshape apply and the data is labeled const to prevent accidental corruption.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">location_tag</td><td>the location of the input/output buffers, <a class="el" href="structheffte_1_1tag_1_1cpu.html" title="Indicates the use of cpu backend and that all input/output data and arrays will be bound to the cpu.">tag::cpu</a> or <a class="el" href="structheffte_1_1tag_1_1gpu.html" title="Indicates the use of gpu backend and that all input/output data and arrays will be bound to the gpu d...">tag::gpu</a> </td></tr>
    <tr><td class="paramname">packer</td><td>is the packer to use to parts of boxes into global send/recv buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>device stream </td></tr>
    <tr><td class="paramname">input_boxes</td><td>list of all input boxes across all ranks in the comm </td></tr>
    <tr><td class="paramname">output_boxes</td><td>list of all output boxes across all ranks in the comm </td></tr>
    <tr><td class="paramname">use_gpu_aware</td><td>use MPI calls directly from the GPU (GPU backends only) </td></tr>
    <tr><td class="paramname">comm</td><td>the communicator associated with all the boxes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr containing an instance of the <a class="el" href="classheffte_1_1reshape3d__alltoallv.html" title="Reshape algorithm based on the MPI_Alltoallv() method.">heffte::reshape3d_alltoallv</a></dd></dl>
<p>Note: the input and output boxes associated with this rank are located at position <a class="el" href="group__hefftempi.html#ga5df7514ec8acb2b7bcc642892ed22f67" title="Returns the rank of this process within the specified comm.">mpi::comm_rank()</a> in the respective lists. </p>

</div>
</div>
<a id="gaccc59d58eea213e0d66f9bb47f3f0525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccc59d58eea213e0d66f9bb47f3f0525">&#9670;&nbsp;</a></span>make_reshape3d_pointtopoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename location_tag , template&lt; typename device &gt; class packer = direct_packer, typename index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classheffte_1_1reshape3d__pointtopoint.html">reshape3d_pointtopoint</a>&lt;location_tag, packer, index&gt; &gt; heffte::make_reshape3d_pointtopoint </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; location_tag &gt;::stream_type&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>output_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fft3d.html#ga4c9d07a6600d0e32939ec064c0604767">reshape_algorithm</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_gpu_aware</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm const&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method that all the necessary work to establish the communication patterns. </p>
<p>The purpose of the factory method is to isolate the initialization code and ensure that the internal state of the class is minimal and const-correct, i.e., objects do not hold onto data that will not be used in a reshape apply and the data is labeled const to prevent accidental corruption.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">location_tag</td><td>the tag for the input/output buffers, <a class="el" href="structheffte_1_1tag_1_1cpu.html" title="Indicates the use of cpu backend and that all input/output data and arrays will be bound to the cpu.">tag::cpu</a> or <a class="el" href="structheffte_1_1tag_1_1gpu.html" title="Indicates the use of gpu backend and that all input/output data and arrays will be bound to the gpu d...">tag::gpu</a> </td></tr>
    <tr><td class="paramname">packer</td><td>is the packer to use to parts of boxes into global send/recv buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>device stream </td></tr>
    <tr><td class="paramname">input_boxes</td><td>list of all input boxes across all ranks in the comm </td></tr>
    <tr><td class="paramname">output_boxes</td><td>list of all output boxes across all ranks in the comm </td></tr>
    <tr><td class="paramname">algorithm</td><td>must be either <a class="el" href="group__fft3d.html#gga4c9d07a6600d0e32939ec064c0604767a705bcf0e77bc8b6fc8e66cbf3c055e6c" title="Using MPI_Send and MPI_Irecv, receive is pipelined with packing and sending.">reshape_algorithm::p2p</a> or <a class="el" href="group__fft3d.html#gga4c9d07a6600d0e32939ec064c0604767a701368ea3fd1a615c4c4c9123514f010" title="Using MPI_Isend and MPI_Irecv, all sending receiving packing and unpacking are pipelined.">reshape_algorithm::p2p_plined</a> </td></tr>
    <tr><td class="paramname">use_gpu_aware</td><td>use MPI calls directly from the GPU (GPU backends only) </td></tr>
    <tr><td class="paramname">comm</td><td>the communicator associated with all the boxes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr containing an instance of the <a class="el" href="classheffte_1_1reshape3d__pointtopoint.html" title="Reshape algorithm based on the MPI_Send() and MPI_Irecv() methods.">heffte::reshape3d_pointtopoint</a></dd></dl>
<p>Note: the input and output boxes associated with this rank are located at position <a class="el" href="group__hefftempi.html#ga5df7514ec8acb2b7bcc642892ed22f67" title="Returns the rank of this process within the specified comm.">mpi::comm_rank()</a> in the respective lists. </p>

</div>
</div>
<a id="ga19f90b121c86d7ed6f0f9c6023523744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19f90b121c86d7ed6f0f9c6023523744">&#9670;&nbsp;</a></span>make_reshape3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename backend_tag , typename index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classheffte_1_1reshape3d__base.html">reshape3d_base</a>&lt;index&gt; &gt; heffte::make_reshape3d </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structheffte_1_1backend_1_1device__instance.html">backend::device_instance</a>&lt; typename <a class="el" href="structheffte_1_1backend_1_1buffer__traits.html">backend::buffer_traits</a>&lt; backend_tag &gt;::location &gt;::stream_type&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>input_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structheffte_1_1box3d.html">box3d</a>&lt; index &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>output_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm const&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structheffte_1_1plan__options.html">plan_options</a> const&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method to create a reshape3d instance. </p>
<p>Creates a reshape operation from the geometry defined by the input boxes to the geometry defined but the output boxes. The boxes are spread across the given MPI communicator where the boxes associated with the current MPI rank is located at input_boxes[mpi::comm_rank(comm)] and output_boxes[mpi::comm_rank(comm)].</p>
<ul>
<li>If the input and output are the same, then an empty unique_ptr is created.</li>
<li>If the geometries differ only in the order, then a <a class="el" href="classheffte_1_1reshape3d__transpose.html" title="Special case of the reshape that does not involve MPI communication but applies a transpose instead.">reshape3d_transpose</a> instance is created.</li>
<li>In all other cases, a <a class="el" href="classheffte_1_1reshape3d__alltoallv.html" title="Reshape algorithm based on the MPI_Alltoallv() method.">reshape3d_alltoallv</a> instance is created using either <a class="el" href="structheffte_1_1direct__packer.html" title="Defines the direct packer without implementation, use the specializations to get the CPU or GPU imple...">direct_packer</a> or <a class="el" href="structheffte_1_1transpose__packer.html" title="Defines the transpose packer without implementation, use the specializations to get the CPU implement...">transpose_packer</a>.</li>
</ul>
<p>Assumes that the order of the input and output geometries are consistent, i.e., input_boxes[i].order == input_boxes[j].order for all i, j. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
